use crate::{coredump, memory, BoxError, Context};
use colored::Colorize;

pub(crate) fn backtrace<R: gimli::Reader>(
    ctx: &Context<R>,
    stack_frames: &Vec<coredump::StackFrame>,
) -> Result<(), BoxError> {
    let mut i = stack_frames.len();
    for frame in stack_frames {
        i -= 1;
        if let Some(selected_frame) = &ctx.selected_frame {
            if selected_frame.binary_name == frame.binary_name {
                print!("#{}*\t", i);
            } else {
                print!("#{}\t", i);
            }
        } else {
            print!("#{}\t", i);
        }

        print_frame(ctx, &frame)?;
    }

    Ok(())
}

pub(crate) fn print_frame<'a, R: gimli::Reader>(
    ctx: &Context<R>,
    frame: &coredump::StackFrame,
) -> Result<(), BoxError> {
    if let Some(func) = ctx.ddbug.functions_by_linkage_name.get(&frame.binary_name) {
        let source = format!(
            "{}/{}",
            func.source()
                .directory()
                .unwrap_or_else(|| "<directory not found>"),
            func.source().file().unwrap_or_else(|| "<file not found>")
        );

        let function = {
            let name = func.name().unwrap();

            let params = func
                .details(&ctx.ddbug)
                .parameters()
                .iter()
                .map(|param| {
                    let param_name = if let Some(name) = param.name() {
                        name
                    } else {
                        "???"
                    };

                    // TODO: not always 4 bytes, right?
                    let size_of = 4;

                    let value = if let Ok(addr) = memory::get_param_addr(frame, &func, param) {
                        let bytes = memory::read(ctx.coredump, addr, size_of).unwrap();
                        format!("0x{}", hex::encode(&bytes))
                    } else {
                        "???".to_owned()
                    };
                    format!("{}={}", param_name.green(), value)
                })
                .collect::<Vec<String>>()
                .join(", ");

            format!("{} ({})", name.yellow(), params)
        };

        let addr = format!("{:0>6}", frame.funcidx).blue();
        println!("{} as {} at {}", addr, function, source);
    } else {
        // Functions that are generated by Wasi and don't have a source (ie
        // some Wasi transpolines) don't have a mapping in DWARF.
        let addr = format!("{:0>6}", frame.funcidx).blue();
        println!("{} as {} at <no location>", addr, frame.binary_name);
    }

    Ok(())
}

pub(crate) fn select_frame<R: gimli::Reader>(
    ctx: &mut Context<R>,
    frame: &coredump::StackFrame,
) -> Result<(), BoxError> {
    // Clear previous selected scope
    ctx.variables.clear();

    let func = ctx
        .ddbug
        .functions_by_linkage_name
        .get(&frame.binary_name)
        .ok_or(format!("function {} not found", frame.binary_name))?;

    for param in func.details(&ctx.ddbug).parameters() {
        if let Some(name) = param.name() {
            ctx.variables.insert(name.to_owned(), param.clone());
        }
    }
    Ok(())
}
