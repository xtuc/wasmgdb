use crate::{coredump, memory, BoxError, Context};
use colored::Colorize;

use wasmgdb_ddbug_parser as ddbug_parser;

pub(crate) fn backtrace(
    ctx: &Context,
    stack_frames: &Vec<coredump::StackFrame>,
) -> Result<(), BoxError> {
    let mut i = stack_frames.len();
    for frame in stack_frames {
        i -= 1;
        if let Some(selected_frame) = &ctx.selected_frame {
            if selected_frame.binary_name == frame.binary_name {
                print!("#{}*\t", i);
            } else {
                print!("#{}\t", i);
            }
        } else {
            print!("#{}\t", i);
        }

        print_frame(ctx, &frame)?;
    }

    Ok(())
}

fn find_location<'a>(ctx: &Context<'a>, search: u64) -> Option<&'a ddbug_parser::Function<'a>> {
    // TODO: optimize with a binary search
    for (_, func) in &ctx.ddbug.functions_by_offset {
        for range in func.ranges() {
            if range.contains(search) {
                return Some(func);
            }
        }
    }

    None
}

pub(crate) fn print_frame<'a>(ctx: &Context, frame: &coredump::StackFrame) -> Result<(), BoxError> {
    if let Some(func) = ctx.ddbug.functions_by_linkage_name.get(&frame.binary_name) {
        let source = format!(
            "{}/{}",
            func.source()
                .directory()
                .unwrap_or_else(|| "<directory not found>"),
            func.source().file().unwrap_or_else(|| "<file not found>")
        );

        let function = {
            let name = func.name().unwrap();

            let params = func
                .details(&ctx.ddbug)
                .parameters()
                .iter()
                .map(|param| {
                    let param_name = if let Some(name) = param.name() {
                        name
                    } else {
                        "???"
                    };

                    // TODO: not always 4 bytes, right?
                    let size_of = 4;

                    let value = if let Ok(addr) = memory::get_param_addr(frame, &func, param) {
                        let bytes = memory::read(ctx.coredump, addr, size_of).unwrap();
                        format!("0x{}", hex::encode(&bytes))
                    } else {
                        "???".to_owned()
                    };
                    format!("{}={}", param_name.green(), value)
                })
                .collect::<Vec<String>>()
                .join(", ");

            format!("{} ({})", name.yellow(), params)

            // if let Some(ref symbol) = found_symbol {
            //     let name = &symbol.name;

            //     let params = symbol
            //         .paramuments
            //         .iter()
            //         .map(|param| {
            //             let param_value = match get_param_value(coredump, &symbol, &frame, &param) {
            //                 Ok(value) => value,
            //                 Err(err) => format!("<{}>", err),
            //             };
            //             format!("{}={}", param.name.green(), param_value)
            //         })
            //         .collect::<Vec<String>>()
            //         .join(", ");
            //     format!("{} ({}) (base={:?})", name.yellow(), params, symbol.base)
            // } else {
            //     format!("{} ()", name.yellow())
            // }
        };

        let addr = format!("{:0>6}", frame.funcidx).blue();
        println!("{} as {} at {}", addr, function, source);
    } else {
        // Functions that are generated by Wasi and don't have a source (ie
        // some Wasi transpolines) don't have a mapping in DWARF.
        let addr = format!("{:0>6}", frame.funcidx).blue();
        println!("{} as {} at <no location>", addr, frame.binary_name);
    }

    Ok(())
}

pub(crate) fn select_frame(
    ctx: &mut Context,
    frame: &coredump::StackFrame,
) -> Result<(), BoxError> {
    // Clear previous selected scope
    ctx.variables.clear();

    let func = ctx
        .ddbug
        .functions_by_linkage_name
        .get(&frame.binary_name)
        .ok_or(format!("function {} not found", frame.binary_name))?;

    for param in func.details(&ctx.ddbug).parameters() {
        if let Some(name) = param.name() {
            ctx.variables.insert(name.to_owned(), param.clone());
        }
    }

    let params = func
        .details(&ctx.ddbug)
        .parameters()
        .iter()
        .map(|param| {
            let param_name = if let Some(name) = param.name() {
                name
            } else {
                "???"
            };

            let ty = param.ty(&ctx.ddbug).unwrap();
            let location = param
                .data_location()
                .map(|l| format!("{:?}", l))
                .unwrap_or_else(|| "???".to_owned());

            format!("{}\t=\t {} (location={})", param_name, ty, location)
        })
        .collect::<Vec<String>>()
        .join("\n");

    println!("frame base\t=\t{:?}", func.frame_base());
    println!("Arguments:\n{}", params);

    Ok(())
}
